/* Build.c generated by valac 0.56.13, the Vala compiler
 * generated from Build.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <stdio.h>
#include <glib-object.h>
#include <gio/gio.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define TYPE_PACKAGE (package_get_type ())
typedef struct _Package Package;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Package {
	gchar* name;
	gchar* author;
	gchar* version;
	gchar* description;
	gchar* binary;
	gchar* dependency;
	gchar* installed_files;
};

VALA_EXTERN void build_create_package (const gchar* usr_dir);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN gboolean build_check (const gchar* usr_dir);
VALA_EXTERN void print_info (const gchar* msg,
                 const gchar* prefix);
VALA_EXTERN GType package_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Package* package_dup (const Package* self);
VALA_EXTERN void package_free (Package* self);
VALA_EXTERN void package_copy (const Package* self,
                   Package* dest);
VALA_EXTERN void package_destroy (Package* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Package, package_destroy)
VALA_EXTERN void package_init_from_file (Package *self,
                             const gchar* info_file);
VALA_EXTERN void package_init_from_input (Package *self);
VALA_EXTERN void package_create_info_file (Package *self,
                               const gchar* info_file);
VALA_EXTERN void build_compress (Package* pkg,
                     const gchar* usr_dir);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

static gchar*
g_file_stream_read_line (FILE* self)
{
	gint c = 0;
	GString* ret = NULL;
	GString* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		GString* _tmp0_;
		GString* _tmp2_;
		c = fgetc (self);
		if (!(c != EOF)) {
			break;
		}
		_tmp0_ = ret;
		if (_tmp0_ == NULL) {
			GString* _tmp1_;
			_tmp1_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp1_;
		}
		if (c == ((gint) '\n')) {
			break;
		}
		_tmp2_ = ret;
		g_string_append_c ((GString*) _tmp2_, (gchar) c);
	}
	_tmp3_ = ret;
	if (_tmp3_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp4_ = ret;
		_tmp5_ = ((GString*) _tmp4_)->str;
		_tmp6_ = g_strdup (_tmp5_);
		result = _tmp6_;
		_g_string_free0 (ret);
		return result;
	}
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

void
build_create_package (const gchar* usr_dir)
{
	gboolean _tmp0_ = FALSE;
	Package pkg = {0};
	const gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gboolean _tmp13_;
	Package _tmp20_;
	g_return_if_fail (usr_dir != NULL);
	if (!g_file_test (usr_dir, G_FILE_TEST_EXISTS)) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !g_file_test (usr_dir, G_FILE_TEST_IS_DIR);
	}
	if (_tmp0_) {
		const gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp1_ = string_to_string (usr_dir);
		_tmp2_ = g_strconcat (_tmp1_, " is not a dir or doesn't exist", NULL);
		_tmp3_ = _tmp2_;
		print_error (_tmp3_);
		_g_free0 (_tmp3_);
	}
	if (build_check (usr_dir) == FALSE) {
		gchar* s = NULL;
		FILE* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		const gchar* _tmp9_;
		print_info ("Your usr_dir is not good are you sure ? [y/N]\n", "SupraPack");
		_tmp4_ = stdin;
		_tmp5_ = g_file_stream_read_line (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) -1);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		s = _tmp8_;
		_tmp9_ = s;
		if (string_contains (_tmp9_, "n")) {
			print_info ("Cancel...", "SupraPack");
			exit (0);
		}
		_g_free0 (s);
	}
	_tmp10_ = string_to_string (usr_dir);
	_tmp11_ = g_strconcat (_tmp10_, "/info", NULL);
	_tmp12_ = _tmp11_;
	_tmp13_ = g_file_test (_tmp12_, G_FILE_TEST_EXISTS);
	_g_free0 (_tmp12_);
	if (_tmp13_) {
		const gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		_tmp14_ = string_to_string (usr_dir);
		_tmp15_ = g_strconcat (_tmp14_, "/info", NULL);
		_tmp16_ = _tmp15_;
		package_destroy (&pkg);
		package_init_from_file (&pkg, _tmp16_);
		_g_free0 (_tmp16_);
	} else {
		const gchar* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		package_destroy (&pkg);
		package_init_from_input (&pkg);
		_tmp17_ = string_to_string (usr_dir);
		_tmp18_ = g_strconcat (_tmp17_, "/info", NULL);
		_tmp19_ = _tmp18_;
		package_create_info_file (&pkg, _tmp19_);
		_g_free0 (_tmp19_);
	}
	_tmp20_ = pkg;
	build_compress (&_tmp20_, usr_dir);
	package_destroy (&pkg);
}

gboolean
build_check (const gchar* usr_dir)
{
	gint n = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gboolean _tmp3_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gboolean _tmp8_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gboolean _tmp13_;
	gboolean result;
	g_return_val_if_fail (usr_dir != NULL, FALSE);
	n = 0;
	_tmp0_ = string_to_string (usr_dir);
	_tmp1_ = g_strconcat (_tmp0_, "/bin", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_EXISTS);
	_g_free0 (_tmp2_);
	if (_tmp3_) {
		gint _tmp4_;
		_tmp4_ = n;
		n = _tmp4_ + 1;
	}
	_tmp5_ = string_to_string (usr_dir);
	_tmp6_ = g_strconcat (_tmp5_, "/lib", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_file_test (_tmp7_, G_FILE_TEST_EXISTS);
	_g_free0 (_tmp7_);
	if (_tmp8_) {
		gint _tmp9_;
		_tmp9_ = n;
		n = _tmp9_ + 1;
	}
	_tmp10_ = string_to_string (usr_dir);
	_tmp11_ = g_strconcat (_tmp10_, "/share", NULL);
	_tmp12_ = _tmp11_;
	_tmp13_ = g_file_test (_tmp12_, G_FILE_TEST_EXISTS);
	_g_free0 (_tmp12_);
	if (_tmp13_) {
		gint _tmp14_;
		_tmp14_ = n;
		n = _tmp14_ + 1;
	}
	result = n != 0;
	return result;
}

void
build_compress (Package* pkg,
                const gchar* usr_dir)
{
	gchar* name_pkg = NULL;
	Package _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	Package _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar** av = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar** _tmp15_;
	gint av_length1;
	gint _av_size_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (pkg != NULL);
	g_return_if_fail (usr_dir != NULL);
	_tmp0_ = *pkg;
	_tmp1_ = _tmp0_.name;
	_tmp2_ = string_to_string (_tmp1_);
	_tmp3_ = *pkg;
	_tmp4_ = _tmp3_.version;
	_tmp5_ = string_to_string (_tmp4_);
	_tmp6_ = g_strconcat (_tmp2_, "-", _tmp5_, NULL);
	name_pkg = _tmp6_;
	_tmp7_ = g_strdup ("tar");
	_tmp8_ = g_strdup ("-cJf");
	_tmp9_ = name_pkg;
	_tmp10_ = string_to_string (_tmp9_);
	_tmp11_ = g_strconcat (_tmp10_, ".suprapack", NULL);
	_tmp12_ = g_strdup ("-C");
	_tmp13_ = g_strdup (usr_dir);
	_tmp14_ = g_strdup (".");
	_tmp15_ = g_new0 (gchar*, 6 + 1);
	_tmp15_[0] = _tmp7_;
	_tmp15_[1] = _tmp8_;
	_tmp15_[2] = _tmp11_;
	_tmp15_[3] = _tmp12_;
	_tmp15_[4] = _tmp13_;
	_tmp15_[5] = _tmp14_;
	av = _tmp15_;
	av_length1 = 6;
	_av_size_ = av_length1;
	{
		GSubprocess* _tmp16_ = NULL;
		gchar** _tmp17_;
		gint _tmp17__length1;
		GSubprocess* _tmp18_;
		_tmp17_ = av;
		_tmp17__length1 = av_length1;
		_tmp18_ = g_subprocess_newv (_tmp17_, G_SUBPROCESS_FLAGS_STDERR_SILENCE, &_inner_error0_);
		_tmp16_ = _tmp18_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		g_subprocess_wait (_tmp16_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (_tmp16_);
			goto __catch0_g_error;
		}
		_g_object_unref0 (_tmp16_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp19_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp19_ = e->message;
		print_error (_tmp19_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		av = (_vala_array_free (av, av_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (name_pkg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp20_ = name_pkg;
	_tmp21_ = string_to_string (_tmp20_);
	_tmp22_ = g_strconcat (_tmp21_, ".suprapack is created\n", NULL);
	_tmp23_ = _tmp22_;
	print_info (_tmp23_, "SupraPack");
	_g_free0 (_tmp23_);
	av = (_vala_array_free (av, av_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (name_pkg);
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

