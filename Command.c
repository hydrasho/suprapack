/* Command.c generated by valac 0.56.13, the Vala compiler
 * generated from Command.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_PACKAGE (package_get_type ())
typedef struct _Package Package;

struct _Package {
	gchar* name;
	gchar* author;
	gchar* version;
	gchar* description;
	gchar* binary;
	gchar* dependency;
	gchar* installed_files;
};

VALA_EXTERN gchar* PREFIX;

VALA_EXTERN gboolean cmd_run (gchar** av,
                  gint av_length1);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN gboolean query_is_exist (const gchar* name_pkg);
VALA_EXTERN void print_info (const gchar* msg,
                 const gchar* prefix);
VALA_EXTERN GType package_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Package* package_dup (const Package* self);
VALA_EXTERN void package_free (Package* self);
VALA_EXTERN void package_copy (const Package* self,
                   Package* dest);
VALA_EXTERN void package_destroy (Package* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Package, package_destroy)
VALA_EXTERN void query_get_from_pkg (const gchar* name_pkg,
                         Package* result);
static void _vala_array_add1 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
VALA_EXTERN gint utils_run (gchar** av,
                gint av_length1,
                gboolean silence,
                gchar** envp,
                gint envp_length1);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

static void
_vala_array_add1 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

gboolean
cmd_run (gchar** av,
         gint av_length1)
{
	const gchar* _tmp0_;
	const gchar* _tmp5_;
	Package pkg = {0};
	const gchar* _tmp10_;
	Package _tmp11_ = {0};
	gchar** av_binary = NULL;
	gint av_binary_length1 = 0;
	gint _av_binary_size_ = 0;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	Package _tmp14_;
	const gchar* _tmp15_;
	const gchar* _tmp16_;
	gchar* _tmp17_;
	gchar** _tmp18_;
	gchar** _tmp22_;
	gint _tmp22__length1;
	gchar** _tmp23_;
	gchar** _tmp24_;
	gchar** _tmp25_;
	gint _tmp25__length1;
	gboolean result;
	if (av_length1 == 2) {
		print_error ("`suprapack run [...]`");
	}
	_tmp0_ = av[2];
	if (query_is_exist (_tmp0_) == FALSE) {
		const gchar* _tmp1_;
		const gchar* _tmp2_;
		gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp1_ = av[2];
		_tmp2_ = string_to_string (_tmp1_);
		_tmp3_ = g_strconcat (_tmp2_, " doesn't exist install it...", NULL);
		_tmp4_ = _tmp3_;
		print_info (_tmp4_, "SupraPack");
		_g_free0 (_tmp4_);
	}
	_tmp5_ = av[2];
	if (query_is_exist (_tmp5_) == FALSE) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp6_ = av[2];
		_tmp7_ = string_to_string (_tmp6_);
		_tmp8_ = g_strconcat (_tmp7_, " is not installed", NULL);
		_tmp9_ = _tmp8_;
		print_error (_tmp9_);
		_g_free0 (_tmp9_);
	}
	_tmp10_ = av[2];
	query_get_from_pkg (_tmp10_, &_tmp11_);
	pkg = _tmp11_;
	_tmp12_ = PREFIX;
	_tmp13_ = string_to_string (_tmp12_);
	_tmp14_ = pkg;
	_tmp15_ = _tmp14_.binary;
	_tmp16_ = string_to_string (_tmp15_);
	_tmp17_ = g_strconcat (_tmp13_, "/", _tmp16_, NULL);
	_tmp18_ = g_new0 (gchar*, 1 + 1);
	_tmp18_[0] = _tmp17_;
	av_binary = (_vala_array_free (av_binary, av_binary_length1, (GDestroyNotify) g_free), NULL);
	av_binary = _tmp18_;
	av_binary_length1 = 1;
	_av_binary_size_ = av_binary_length1;
	if (av_length1 >= 3) {
		{
			gchar** i_collection = NULL;
			gint i_collection_length1 = 0;
			gint _i_collection_size_ = 0;
			gint i_it = 0;
			i_collection = av + 3;
			i_collection_length1 = av_length1 - 3;
			for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
				gchar* _tmp19_;
				gchar* i = NULL;
				_tmp19_ = g_strdup (i_collection[i_it]);
				i = _tmp19_;
				{
					const gchar* _tmp20_;
					gchar* _tmp21_;
					_tmp20_ = i;
					_tmp21_ = g_strdup (_tmp20_);
					_vala_array_add1 (&av_binary, &av_binary_length1, &_av_binary_size_, _tmp21_);
					_g_free0 (i);
				}
			}
		}
	}
	_tmp22_ = av_binary;
	_tmp22__length1 = av_binary_length1;
	_tmp24_ = _tmp23_ = g_get_environ ();
	_tmp25_ = _tmp24_;
	_tmp25__length1 = _vala_array_length (_tmp23_);
	utils_run (_tmp22_, (gint) _tmp22__length1, FALSE, _tmp25_, (gint) _vala_array_length (_tmp23_));
	_tmp25_ = (_vala_array_free (_tmp25_, _tmp25__length1, (GDestroyNotify) g_free), NULL);
	result = TRUE;
	av_binary = (_vala_array_free (av_binary, av_binary_length1, (GDestroyNotify) g_free), NULL);
	package_destroy (&pkg);
	return result;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

