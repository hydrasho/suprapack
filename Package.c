/* Package.c generated by valac 0.56.13, the Vala compiler
 * generated from Package.vala, do not modify */

/* Package struct*/
/* can build package*/
/* can extract package*/

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_PACKAGE (package_get_type ())
typedef struct _Package Package;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Package {
	gchar* name;
	gchar* author;
	gchar* version;
	gchar* description;
	gchar* binary;
	gchar* dependency;
	gchar* installed_files;
};

VALA_EXTERN GType package_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Package* package_dup (const Package* self);
VALA_EXTERN void package_free (Package* self);
VALA_EXTERN void package_copy (const Package* self,
                   Package* dest);
VALA_EXTERN void package_destroy (Package* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Package, package_destroy)
VALA_EXTERN void package_init_from_file (Package *self,
                             const gchar* info_file);
VALA_EXTERN gchar** package_get_installed_files (Package *self,
                                     gint* result_length1);
VALA_EXTERN void package_create_info_file (Package *self,
                               const gchar* info_file);

void
package_init_from_file (Package *self,
                        const gchar* info_file)
{
	g_return_if_fail (info_file != NULL);
	memset (self, 0, sizeof (Package));
}

gchar**
package_get_installed_files (Package *self,
                             gint* result_length1)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar** _tmp3_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gchar** result;
	_tmp0_ = g_strdup ("a");
	_tmp1_ = g_strdup ("b");
	_tmp2_ = g_strdup ("c");
	_tmp3_ = g_new0 (gchar*, 3 + 1);
	_tmp3_[0] = _tmp0_;
	_tmp3_[1] = _tmp1_;
	_tmp3_[2] = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = 3;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}

void
package_create_info_file (Package *self,
                          const gchar* info_file)
{
	g_return_if_fail (info_file != NULL);
}

void
package_copy (const Package* self,
              Package* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).author;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).author);
	(*dest).author = _tmp3_;
	_tmp4_ = (*self).version;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*dest).version);
	(*dest).version = _tmp5_;
	_tmp6_ = (*self).description;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 ((*dest).description);
	(*dest).description = _tmp7_;
	_tmp8_ = (*self).binary;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 ((*dest).binary);
	(*dest).binary = _tmp9_;
	_tmp10_ = (*self).dependency;
	_tmp11_ = g_strdup (_tmp10_);
	_g_free0 ((*dest).dependency);
	(*dest).dependency = _tmp11_;
	_tmp12_ = (*self).installed_files;
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 ((*dest).installed_files);
	(*dest).installed_files = _tmp13_;
}

void
package_destroy (Package* self)
{
	_g_free0 ((*self).name);
	_g_free0 ((*self).author);
	_g_free0 ((*self).version);
	_g_free0 ((*self).description);
	_g_free0 ((*self).binary);
	_g_free0 ((*self).dependency);
	_g_free0 ((*self).installed_files);
}

Package*
package_dup (const Package* self)
{
	Package* dup;
	dup = g_new0 (Package, 1);
	package_copy (self, dup);
	return dup;
}

void
package_free (Package* self)
{
	package_destroy (self);
	g_free (self);
}

static GType
package_get_type_once (void)
{
	GType package_type_id;
	package_type_id = g_boxed_type_register_static ("Package", (GBoxedCopyFunc) package_dup, (GBoxedFreeFunc) package_free);
	return package_type_id;
}

GType
package_get_type (void)
{
	static volatile gsize package_type_id__once = 0;
	if (g_once_init_enter (&package_type_id__once)) {
		GType package_type_id;
		package_type_id = package_get_type_once ();
		g_once_init_leave (&package_type_id__once, package_type_id);
	}
	return package_type_id__once;
}

