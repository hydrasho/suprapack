/* Package.c generated by valac 0.56.13, the Vala compiler
 * generated from Package.vala, do not modify */

/* Package struct*/
/* can build package*/
/* can extract package*/

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <stdio.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_PACKAGE (package_get_type ())
typedef struct _Package Package;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

struct _Package {
	gchar* name;
	gchar* author;
	gchar* version;
	gchar* description;
	gchar* binary;
	gchar* dependency;
	gchar* installed_files;
};

VALA_EXTERN GType package_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Package* package_dup (const Package* self);
VALA_EXTERN void package_free (Package* self);
VALA_EXTERN void package_copy (const Package* self,
                   Package* dest);
VALA_EXTERN void package_destroy (Package* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Package, package_destroy)
static void package_init (Package *self);
VALA_EXTERN void package_init_from_input (Package *self);
VALA_EXTERN gchar* utils_get_input (const gchar* msg);
VALA_EXTERN void package_init_from_file (Package *self,
                             const gchar* info_file);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN gchar** package_get_installed_files (Package *self,
                                     gint* result_length1);
VALA_EXTERN void package_create_info_file (Package *self,
                               const gchar* info_file);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static void
package_init (Package *self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	_tmp0_ = g_strdup ("");
	_g_free0 ((*self).name);
	(*self).name = _tmp0_;
	_tmp1_ = g_strdup ("");
	_g_free0 ((*self).author);
	(*self).author = _tmp1_;
	_tmp2_ = g_strdup ("");
	_g_free0 ((*self).version);
	(*self).version = _tmp2_;
	_tmp3_ = g_strdup ("");
	_g_free0 ((*self).description);
	(*self).description = _tmp3_;
	_tmp4_ = g_strdup ("");
	_g_free0 ((*self).binary);
	(*self).binary = _tmp4_;
	_tmp5_ = g_strdup ("");
	_g_free0 ((*self).dependency);
	(*self).dependency = _tmp5_;
	_tmp6_ = g_strdup ("");
	_g_free0 ((*self).installed_files);
	(*self).installed_files = _tmp6_;
}

void
package_init_from_input (Package *self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	memset (self, 0, sizeof (Package));
	_tmp0_ = utils_get_input ("Name: ");
	_g_free0 ((*self).name);
	(*self).name = _tmp0_;
	_tmp1_ = utils_get_input ("Version: ");
	_g_free0 ((*self).version);
	(*self).version = _tmp1_;
	_tmp2_ = utils_get_input ("Author: ");
	_g_free0 ((*self).author);
	(*self).author = _tmp2_;
	_tmp3_ = utils_get_input ("Description: ");
	_g_free0 ((*self).description);
	(*self).description = _tmp3_;
	_tmp4_ = utils_get_input ("Dependency: ");
	_g_free0 ((*self).dependency);
	(*self).dependency = _tmp4_;
	_tmp5_ = (*self).name;
	g_print ("Can be empty if %s is the binary name\n", _tmp5_);
	_tmp6_ = utils_get_input ("Binary: ");
	_g_free0 ((*self).binary);
	(*self).binary = _tmp6_;
	_tmp7_ = g_strdup ("");
	_g_free0 ((*self).installed_files);
	(*self).installed_files = _tmp7_;
}

static const gchar*
string_offset (const gchar* self,
               glong offset)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (const gchar*) (((gchar*) self) + offset);
	return result;
}

static gint
string_index_of_char (const gchar* self,
                      gunichar c,
                      gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

static gint
string_index_of (const gchar* self,
                 const gchar* needle,
                 gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = strstr (((gchar*) self) + start_index, (gchar*) needle);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

void
package_init_from_file (Package *self,
                        const gchar* info_file)
{
	gchar* contents = NULL;
	gsize len = 0UL;
	const gchar* value = NULL;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (info_file != NULL);
	memset (self, 0, sizeof (Package));
	package_init (&(*self));
	{
		gchar* _tmp0_ = NULL;
		gsize _tmp1_ = 0UL;
		gchar** lines = NULL;
		const gchar* _tmp2_;
		gchar** _tmp3_;
		gchar** _tmp4_;
		gint lines_length1;
		gint _lines_size_;
		gchar** _tmp5_;
		gint _tmp5__length1;
		const gchar* _tmp29_;
		const gchar* _tmp35_;
		g_file_get_contents (info_file, &_tmp0_, &_tmp1_, &_inner_error0_);
		_g_free0 (contents);
		contents = _tmp0_;
		len = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp2_ = contents;
		_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, "\n", 0);
		lines = _tmp4_;
		lines_length1 = _vala_array_length (_tmp3_);
		_lines_size_ = lines_length1;
		_tmp5_ = lines;
		_tmp5__length1 = lines_length1;
		{
			gchar** line_collection = NULL;
			gint line_collection_length1 = 0;
			gint _line_collection_size_ = 0;
			gint line_it = 0;
			line_collection = _tmp5_;
			line_collection_length1 = _tmp5__length1;
			for (line_it = 0; line_it < line_collection_length1; line_it = line_it + 1) {
				gchar* _tmp6_;
				gchar* line = NULL;
				_tmp6_ = g_strdup (line_collection[line_it]);
				line = _tmp6_;
				{
					const gchar* _tmp7_;
					const gchar* _tmp8_;
					const gchar* _tmp9_;
					const gchar* _tmp10_;
					const gchar* _tmp11_;
					const gchar* _tmp14_;
					const gchar* _tmp17_;
					const gchar* _tmp20_;
					const gchar* _tmp23_;
					const gchar* _tmp26_;
					_tmp7_ = line;
					if (g_strcmp0 (_tmp7_, "[FILES]") == 0) {
						_g_free0 (line);
						break;
					}
					_tmp8_ = line;
					_tmp9_ = line;
					_tmp10_ = string_offset (_tmp8_, (glong) (string_index_of_char (_tmp9_, (gunichar) ':', 0) + 1));
					value = _tmp10_;
					_tmp11_ = line;
					if (g_str_has_prefix (_tmp11_, "name")) {
						const gchar* _tmp12_;
						gchar* _tmp13_;
						_tmp12_ = value;
						_tmp13_ = string_strip (_tmp12_);
						_g_free0 ((*self).name);
						(*self).name = _tmp13_;
					}
					_tmp14_ = line;
					if (g_str_has_prefix (_tmp14_, "version")) {
						const gchar* _tmp15_;
						gchar* _tmp16_;
						_tmp15_ = value;
						_tmp16_ = string_strip (_tmp15_);
						_g_free0 ((*self).version);
						(*self).version = _tmp16_;
					}
					_tmp17_ = line;
					if (g_str_has_prefix (_tmp17_, "author")) {
						const gchar* _tmp18_;
						gchar* _tmp19_;
						_tmp18_ = value;
						_tmp19_ = string_strip (_tmp18_);
						_g_free0 ((*self).author);
						(*self).author = _tmp19_;
					}
					_tmp20_ = line;
					if (g_str_has_prefix (_tmp20_, "description")) {
						const gchar* _tmp21_;
						gchar* _tmp22_;
						_tmp21_ = value;
						_tmp22_ = string_strip (_tmp21_);
						_g_free0 ((*self).description);
						(*self).description = _tmp22_;
					}
					_tmp23_ = line;
					if (g_str_has_prefix (_tmp23_, "binary")) {
						const gchar* _tmp24_;
						gchar* _tmp25_;
						_tmp24_ = value;
						_tmp25_ = string_strip (_tmp24_);
						_g_free0 ((*self).binary);
						(*self).binary = _tmp25_;
					}
					_tmp26_ = line;
					if (g_str_has_prefix (_tmp26_, "dependency")) {
						const gchar* _tmp27_;
						gchar* _tmp28_;
						_tmp27_ = value;
						_tmp28_ = string_strip (_tmp27_);
						_g_free0 ((*self).dependency);
						(*self).dependency = _tmp28_;
					}
					_g_free0 (line);
				}
			}
		}
		_tmp29_ = contents;
		if (string_contains (_tmp29_, "[FILES]")) {
			const gchar* _tmp30_;
			const gchar* _tmp31_;
			const gchar* _tmp32_;
			const gchar* _tmp33_;
			gchar* _tmp34_;
			_tmp30_ = contents;
			_tmp31_ = contents;
			_tmp32_ = string_offset (_tmp30_, (glong) (string_index_of (_tmp31_, "[FILES]", 0) + 8));
			value = _tmp32_;
			_tmp33_ = value;
			_tmp34_ = g_strdup (_tmp33_);
			_g_free0 ((*self).installed_files);
			(*self).installed_files = _tmp34_;
		}
		_tmp35_ = (*self).binary;
		if (g_strcmp0 (_tmp35_, "") == 0) {
			const gchar* _tmp36_;
			gchar* _tmp37_;
			_tmp36_ = (*self).name;
			_tmp37_ = g_strdup (_tmp36_);
			_g_free0 ((*self).binary);
			(*self).binary = _tmp37_;
		}
		lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp38_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp38_ = e->message;
		print_error (_tmp38_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (contents);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (contents);
}

gchar**
package_get_installed_files (Package *self,
                             gint* result_length1)
{
	gchar** sp = NULL;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_;
	gint sp_length1;
	gint _sp_size_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar** _tmp4_;
	gint _tmp4__length1;
	const gchar* _tmp5_;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar** result;
	_tmp0_ = (*self).installed_files;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "\n", 0);
	sp = _tmp2_;
	sp_length1 = _vala_array_length (_tmp1_);
	_sp_size_ = sp_length1;
	_tmp3_ = sp;
	_tmp3__length1 = sp_length1;
	_tmp4_ = sp;
	_tmp4__length1 = sp_length1;
	_tmp5_ = _tmp3_[_tmp4__length1 - 1];
	if (g_strcmp0 (_tmp5_, "") == 0) {
		gchar** _tmp6_;
		gint _tmp6__length1;
		gchar** _tmp7_;
		gint _tmp7__length1;
		gchar** _tmp8_;
		gint _tmp8__length1;
		gint _tmp9_;
		_tmp6_ = sp;
		_tmp6__length1 = sp_length1;
		_tmp7_ = sp;
		_tmp7__length1 = sp_length1;
		_g_free0 (_tmp6_[_tmp7__length1 - 1]);
		_tmp6_[_tmp7__length1 - 1] = NULL;
		_tmp8_ = sp;
		_tmp8__length1 = sp_length1;
		_tmp9_ = _tmp8__length1 - 1;
		sp = g_renew (gchar*, sp, _tmp8__length1 - 1);
		(_tmp9_ > sp_length1) ? memset (sp + sp_length1, 0, sizeof (gchar*) * (_tmp9_ - sp_length1)) : NULL;
		sp_length1 = _tmp9_;
		_sp_size_ = _tmp9_;
	}
	_tmp10_ = sp;
	_tmp10__length1 = sp_length1;
	if (result_length1) {
		*result_length1 = _tmp10__length1;
	}
	result = _tmp10_;
	return result;
}

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

void
package_create_info_file (Package *self,
                          const gchar* info_file)
{
	FILE* fs = NULL;
	FILE* _tmp0_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	g_return_if_fail (info_file != NULL);
	_tmp0_ = g_fopen (info_file, "w");
	fs = _tmp0_;
	if (fs == NULL) {
		const gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp1_ = string_to_string (info_file);
		_tmp2_ = g_strconcat ("cant open ", _tmp1_, NULL);
		_tmp3_ = _tmp2_;
		print_error (_tmp3_);
		_g_free0 (_tmp3_);
	}
	_tmp4_ = (*self).name;
	fprintf (fs, "name: %s\n", _tmp4_);
	_tmp5_ = (*self).version;
	fprintf (fs, "version: %s\n", _tmp5_);
	_tmp6_ = (*self).author;
	fprintf (fs, "author: %s\n", _tmp6_);
	_tmp7_ = (*self).binary;
	fprintf (fs, "binary: %s\n", _tmp7_);
	_tmp8_ = (*self).description;
	fprintf (fs, "description: %s\n", _tmp8_);
	_tmp9_ = (*self).dependency;
	fprintf (fs, "dependency: %s\n", _tmp9_);
	_fclose0 (fs);
}

void
package_copy (const Package* self,
              Package* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).author;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).author);
	(*dest).author = _tmp3_;
	_tmp4_ = (*self).version;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*dest).version);
	(*dest).version = _tmp5_;
	_tmp6_ = (*self).description;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 ((*dest).description);
	(*dest).description = _tmp7_;
	_tmp8_ = (*self).binary;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 ((*dest).binary);
	(*dest).binary = _tmp9_;
	_tmp10_ = (*self).dependency;
	_tmp11_ = g_strdup (_tmp10_);
	_g_free0 ((*dest).dependency);
	(*dest).dependency = _tmp11_;
	_tmp12_ = (*self).installed_files;
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 ((*dest).installed_files);
	(*dest).installed_files = _tmp13_;
}

void
package_destroy (Package* self)
{
	_g_free0 ((*self).name);
	_g_free0 ((*self).author);
	_g_free0 ((*self).version);
	_g_free0 ((*self).description);
	_g_free0 ((*self).binary);
	_g_free0 ((*self).dependency);
	_g_free0 ((*self).installed_files);
}

Package*
package_dup (const Package* self)
{
	Package* dup;
	dup = g_new0 (Package, 1);
	package_copy (self, dup);
	return dup;
}

void
package_free (Package* self)
{
	package_destroy (self);
	g_free (self);
}

static GType
package_get_type_once (void)
{
	GType package_type_id;
	package_type_id = g_boxed_type_register_static ("Package", (GBoxedCopyFunc) package_dup, (GBoxedFreeFunc) package_free);
	return package_type_id;
}

GType
package_get_type (void)
{
	static volatile gsize package_type_id__once = 0;
	if (g_once_init_enter (&package_type_id__once)) {
		GType package_type_id;
		package_type_id = package_get_type_once ();
		g_once_init_leave (&package_type_id__once, package_type_id);
	}
	return package_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

