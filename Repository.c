/* Repository.c generated by valac 0.56.13, the Vala compiler
 * generated from Repository.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <stdio.h>
#include <glib/gstdio.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

VALA_EXTERN gchar** repository_list_file_in_dir (const gchar* dir_name,
                                     gint* result_length1);
static void _vala_array_add1 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN void repository_prepare (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static void
_vala_array_add1 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

gchar**
repository_list_file_in_dir (const gchar* dir_name,
                             gint* result_length1)
{
	GError* _inner_error0_ = NULL;
	gchar** result;
	g_return_val_if_fail (dir_name != NULL, NULL);
	{
		GDir* dir = NULL;
		GDir* _tmp0_;
		gchar** _result_ = NULL;
		gchar** _tmp1_;
		gint _result__length1;
		gint __result__size_;
		const gchar* tmp = NULL;
		gchar** _tmp7_;
		gint _tmp7__length1;
		_tmp0_ = g_dir_open (dir_name, (guint) 0, &_inner_error0_);
		dir = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp1_ = g_new0 (gchar*, 0 + 1);
		_result_ = _tmp1_;
		_result__length1 = 0;
		__result__size_ = _result__length1;
		while (TRUE) {
			const gchar* _tmp2_;
			const gchar* _tmp3_;
			const gchar* _tmp4_;
			_tmp2_ = g_dir_read_name (dir);
			tmp = _tmp2_;
			_tmp3_ = tmp;
			if (!(_tmp3_ != NULL)) {
				break;
			}
			_tmp4_ = tmp;
			if (g_str_has_suffix (_tmp4_, ".suprapack")) {
				const gchar* _tmp5_;
				gchar* _tmp6_;
				_tmp5_ = tmp;
				_tmp6_ = g_strdup (_tmp5_);
				_vala_array_add1 (&_result_, &_result__length1, &__result__size_, _tmp6_);
			}
		}
		_tmp7_ = _result_;
		_tmp7__length1 = _result__length1;
		if (result_length1) {
			*result_length1 = _tmp7__length1;
		}
		result = _tmp7_;
		_g_dir_close0 (dir);
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp8_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp8_ = e->message;
		print_error (_tmp8_);
		_g_error_free0 (e);
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return NULL;
}

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

void
repository_prepare (void)
{
	gchar* pwd = NULL;
	gchar* _tmp0_;
	gchar** lst = NULL;
	gint _tmp1_ = 0;
	gchar** _tmp2_;
	gint lst_length1;
	gint _lst_size_;
	FILE* fs = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	FILE* _tmp6_;
	FILE* _tmp7_;
	_tmp0_ = g_get_current_dir ();
	pwd = _tmp0_;
	_tmp2_ = repository_list_file_in_dir (pwd, &_tmp1_);
	lst = _tmp2_;
	lst_length1 = _tmp1_;
	_lst_size_ = lst_length1;
	_tmp3_ = string_to_string (pwd);
	_tmp4_ = g_strconcat (_tmp3_, "/list", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_fopen (_tmp5_, "w");
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	fs = _tmp7_;
	if (fs == NULL) {
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp8_ = string_to_string (pwd);
		_tmp9_ = g_strconcat ("Cant create ", _tmp8_, "/list", NULL);
		_tmp10_ = _tmp9_;
		print_error (_tmp10_);
		_g_free0 (_tmp10_);
	}
	{
		gchar** file_collection = NULL;
		gint file_collection_length1 = 0;
		gint _file_collection_size_ = 0;
		gint file_it = 0;
		file_collection = lst;
		file_collection_length1 = lst_length1;
		for (file_it = 0; file_it < file_collection_length1; file_it = file_it + 1) {
			gchar* _tmp11_;
			gchar* file = NULL;
			_tmp11_ = g_strdup (file_collection[file_it]);
			file = _tmp11_;
			{
				const gchar* _tmp12_;
				_tmp12_ = file;
				fprintf (fs, "%s\n", _tmp12_);
				_g_free0 (file);
			}
		}
	}
	_fclose0 (fs);
	lst = (_vala_array_free (lst, lst_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (pwd);
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

