/* Install.c generated by valac 0.56.13, the Vala compiler
 * generated from Install.vala, do not modify */

#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <glib-object.h>
#include <stdio.h>
#include <gio/gio.h>

#define SIZE_TMP_DIR 22
#define BOLD "\033[;1m"
#define YELLOW "\033[33m"
#define NONE "\033[0m"
#define CYAN "\033[96m"
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_PACKAGE (package_get_type ())
typedef struct _Package Package;
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_SYNC (sync_get_type ())
#define SYNC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SYNC, Sync))
#define SYNC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SYNC, SyncClass))
#define IS_SYNC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SYNC))
#define IS_SYNC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SYNC))
#define SYNC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SYNC, SyncClass))

typedef struct _Sync Sync;
typedef struct _SyncClass SyncClass;

#define TYPE_SUPRA_LIST (supra_list_get_type ())
typedef struct _SupraList SupraList;
#define _sync_unref0(var) ((var == NULL) ? NULL : (var = (sync_unref (var), NULL)))

struct _Package {
	gchar* name;
	gchar* author;
	gchar* version;
	gchar* description;
	gchar* binary;
	gchar* dependency;
	gchar* installed_files;
};

struct _SupraList {
	const gchar* repo_name;
	gchar* name;
	gchar* version;
};

VALA_EXTERN gchar* LOCAL;
VALA_EXTERN gchar* PREFIX;

VALA_EXTERN void list_file_dir (const gchar* emp_dir,
                    GList** list);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN GType package_get_type (void) G_GNUC_CONST ;
VALA_EXTERN Package* package_dup (const Package* self);
VALA_EXTERN void package_free (Package* self);
VALA_EXTERN void package_copy (const Package* self,
                   Package* dest);
VALA_EXTERN void package_destroy (Package* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (Package, package_destroy)
VALA_EXTERN void post_install (GList* list,
                   gint len,
                   Package* pkg);
VALA_EXTERN void package_create_info_file (Package *self,
                               const gchar* info_file);
VALA_EXTERN void draw_install_file (guint min,
                        guint max,
                        const gchar* file);
VALA_EXTERN void install_files (GList* list,
                    gint len);
VALA_EXTERN void script_pre_install (const gchar* dir);
VALA_EXTERN void print_info (const gchar* msg,
                 const gchar* prefix);
static gchar** _vala_array_dup2 (gchar** self,
                          gssize length);
static gchar** _vala_array_dup3 (gchar** self,
                          gssize length);
VALA_EXTERN gint utils_run (gchar** av,
                gint av_length1,
                gboolean silence,
                gchar** envp,
                gint envp_length1);
VALA_EXTERN void script_post_install (const gchar* dir);
static gchar** _vala_array_dup4 (gchar** self,
                          gssize length);
static gchar** _vala_array_dup5 (gchar** self,
                          gssize length);
VALA_EXTERN void install_suprapackage (const gchar* suprapack);
VALA_EXTERN void utils_create_pixmaps_link (void);
VALA_EXTERN void package_init_from_file (Package *self,
                             const gchar* info_file);
VALA_EXTERN gboolean query_is_exist (const gchar* name_pkg);
VALA_EXTERN void query_uninstall (const gchar* name_pkg);
VALA_EXTERN void install (const gchar* name_search,
              gboolean force);
static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
VALA_EXTERN gpointer sync_ref (gpointer instance);
VALA_EXTERN void sync_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_sync (const gchar* name,
                             const gchar* nick,
                             const gchar* blurb,
                             GType object_type,
                             GParamFlags flags);
VALA_EXTERN void value_set_sync (GValue* value,
                     gpointer v_object);
VALA_EXTERN void value_take_sync (GValue* value,
                      gpointer v_object);
VALA_EXTERN gpointer value_get_sync (const GValue* value);
VALA_EXTERN GType sync_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Sync, sync_unref)
VALA_EXTERN Sync* sync_default (void);
VALA_EXTERN GType supra_list_get_type (void) G_GNUC_CONST ;
VALA_EXTERN SupraList* supra_list_dup (const SupraList* self);
VALA_EXTERN void supra_list_free (SupraList* self);
VALA_EXTERN void supra_list_copy (const SupraList* self,
                      SupraList* dest);
VALA_EXTERN void supra_list_destroy (SupraList* self);
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC (SupraList, supra_list_destroy)
VALA_EXTERN SupraList* sync_get_list_package (Sync* self,
                                  gint* result_length1);
VALA_EXTERN gboolean sync_check_update (const gchar* package_name);
VALA_EXTERN gboolean update_package (const gchar* pkg_name,
                         gboolean force);
static void _vala_SupraList_array_free (SupraList * array,
                                 gssize array_length);
VALA_EXTERN gchar* sync_download (Sync* self,
                      SupraList* pkg);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

void
list_file_dir (const gchar* emp_dir,
               GList** list)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (emp_dir != NULL);
	{
		GDir* dir = NULL;
		GDir* _tmp0_;
		const gchar* it = NULL;
		_tmp0_ = g_dir_open (emp_dir, (guint) 0, &_inner_error0_);
		dir = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		while (TRUE) {
			GDir* _tmp1_;
			const gchar* _tmp2_;
			const gchar* _tmp3_;
			gint _tmp4_;
			gint _tmp5_;
			gchar* name = NULL;
			const gchar* _tmp11_;
			const gchar* _tmp12_;
			const gchar* _tmp13_;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			_tmp1_ = dir;
			_tmp2_ = g_dir_read_name (_tmp1_);
			it = _tmp2_;
			_tmp3_ = it;
			if (!(_tmp3_ != NULL)) {
				break;
			}
			_tmp4_ = strlen (emp_dir);
			_tmp5_ = _tmp4_;
			if (_tmp5_ == SIZE_TMP_DIR) {
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				const gchar* _tmp8_;
				_tmp8_ = it;
				if (g_strcmp0 (_tmp8_, "info") == 0) {
					_tmp7_ = TRUE;
				} else {
					const gchar* _tmp9_;
					_tmp9_ = it;
					_tmp7_ = g_strcmp0 (_tmp9_, "pre_install.sh") == 0;
				}
				if (_tmp7_) {
					_tmp6_ = TRUE;
				} else {
					const gchar* _tmp10_;
					_tmp10_ = it;
					_tmp6_ = g_strcmp0 (_tmp10_, "post_install.sh") == 0;
				}
				if (_tmp6_) {
					continue;
				}
			}
			_tmp11_ = string_to_string (emp_dir);
			_tmp12_ = it;
			_tmp13_ = string_to_string (_tmp12_);
			_tmp14_ = g_strconcat (_tmp11_, "/", _tmp13_, NULL);
			name = _tmp14_;
			_tmp15_ = name;
			if (g_file_test (_tmp15_, G_FILE_TEST_IS_DIR)) {
				const gchar* _tmp16_;
				_tmp16_ = name;
				list_file_dir (_tmp16_, list);
			} else {
				const gchar* _tmp17_;
				gchar* _tmp18_;
				_tmp17_ = name;
				_tmp18_ = g_strdup (_tmp17_);
				*list = g_list_append (*list, _tmp18_);
			}
			_g_free0 (name);
		}
		_g_dir_close0 (dir);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp19_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp19_ = e->message;
		print_error (_tmp19_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static const gchar*
string_offset (const gchar* self,
               glong offset)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = (const gchar*) (((gchar*) self) + offset);
	return result;
}

void
post_install (GList* list,
              gint len,
              Package* pkg)
{
	gchar* packinfo = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	Package _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* info_file = NULL;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	FILE* fs = NULL;
	FILE* _tmp8_;
	g_return_if_fail (pkg != NULL);
	_tmp0_ = LOCAL;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = *pkg;
	_tmp3_ = _tmp2_.name;
	_tmp4_ = string_to_string (_tmp3_);
	_tmp5_ = g_strconcat (_tmp1_, "/", _tmp4_, NULL);
	packinfo = _tmp5_;
	_tmp6_ = string_to_string (packinfo);
	_tmp7_ = g_strconcat (_tmp6_, "/info", NULL);
	info_file = _tmp7_;
	g_mkdir_with_parents (packinfo, 0755);
	package_create_info_file (pkg, info_file);
	_tmp8_ = g_fopen (info_file, "a");
	fs = _tmp8_;
	if (fs == NULL) {
		const gchar* _tmp9_;
		gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp9_ = string_to_string (info_file);
		_tmp10_ = g_strconcat ("Cant open ", _tmp9_, NULL);
		_tmp11_ = _tmp10_;
		print_error (_tmp11_);
		_g_free0 (_tmp11_);
	}
	fprintf (fs, "[FILES]\n");
	{
		GList* i_collection = NULL;
		GList* i_it = NULL;
		i_collection = list;
		for (i_it = i_collection; i_it != NULL; i_it = i_it->next) {
			gchar* _tmp12_;
			gchar* i = NULL;
			_tmp12_ = g_strdup ((const gchar*) i_it->data);
			i = _tmp12_;
			{
				const gchar* basename = NULL;
				const gchar* _tmp13_;
				const gchar* _tmp14_;
				const gchar* _tmp15_;
				_tmp13_ = i;
				_tmp14_ = string_offset (_tmp13_, (glong) len);
				basename = _tmp14_;
				_tmp15_ = basename;
				if (g_strcmp0 (_tmp15_, "/info") != 0) {
					const gchar* _tmp16_;
					const gchar* _tmp17_;
					_tmp16_ = PREFIX;
					_tmp17_ = basename;
					fprintf (fs, "%s%s\n", _tmp16_, _tmp17_);
				}
				_g_free0 (i);
			}
		}
	}
	_fclose0 (fs);
	_g_free0 (info_file);
	_g_free0 (packinfo);
}

void
draw_install_file (guint min,
                   guint max,
                   const gchar* file)
{
	FILE* _tmp0_;
	g_return_if_fail (file != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "%s%s[Install]%s [%u/%u] %s\n", BOLD, YELLOW, NONE, min, max, file);
}

static gchar*
string_slice (const gchar* self,
              glong start,
              glong end)
{
	glong string_length = 0L;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gchar* _tmp4_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	if (start < ((glong) 0)) {
		start = string_length + start;
	}
	if (end < ((glong) 0)) {
		end = string_length + end;
	}
	if (start >= ((glong) 0)) {
		_tmp2_ = start <= string_length;
	} else {
		_tmp2_ = FALSE;
	}
	g_return_val_if_fail (_tmp2_, NULL);
	if (end >= ((glong) 0)) {
		_tmp3_ = end <= string_length;
	} else {
		_tmp3_ = FALSE;
	}
	g_return_val_if_fail (_tmp3_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	_tmp4_ = g_strndup (((gchar*) self) + start, (gsize) (end - start));
	result = _tmp4_;
	return result;
}

static gint
string_last_index_of_char (const gchar* self,
                           gunichar c,
                           gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strrchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

void
install_files (GList* list,
               gint len)
{
	guint nb = 0U;
	const gchar* basename = NULL;
	guint list_length = 0U;
	GError* _inner_error0_ = NULL;
	nb = (guint) 0;
	list_length = g_list_length (list);
	{
		{
			GList* e_collection = NULL;
			GList* e_it = NULL;
			e_collection = list;
			for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
				gchar* _tmp0_;
				gchar* e = NULL;
				_tmp0_ = g_strdup ((const gchar*) e_it->data);
				e = _tmp0_;
				{
					const gchar* _tmp1_;
					const gchar* _tmp2_;
					GFile* fileSrc = NULL;
					const gchar* _tmp3_;
					GFile* _tmp4_;
					GFile* fileDest = NULL;
					const gchar* _tmp5_;
					const gchar* _tmp6_;
					gchar* _tmp7_;
					gchar* _tmp8_;
					GFile* _tmp9_;
					GFile* _tmp10_;
					gchar* path = NULL;
					GFile* _tmp11_;
					gchar* _tmp12_;
					const gchar* _tmp13_;
					const gchar* _tmp14_;
					gchar* _tmp15_;
					const gchar* _tmp16_;
					GFile* _tmp17_;
					GFile* _tmp18_;
					guint _tmp19_;
					guint _tmp20_;
					const gchar* _tmp21_;
					_tmp1_ = e;
					_tmp2_ = string_offset (_tmp1_, (glong) len);
					basename = _tmp2_;
					_tmp3_ = e;
					_tmp4_ = g_file_new_for_path (_tmp3_);
					fileSrc = _tmp4_;
					_tmp5_ = PREFIX;
					_tmp6_ = basename;
					_tmp7_ = g_strconcat (_tmp5_, _tmp6_, NULL);
					_tmp8_ = _tmp7_;
					_tmp9_ = g_file_new_for_path (_tmp8_);
					_tmp10_ = _tmp9_;
					_g_free0 (_tmp8_);
					fileDest = _tmp10_;
					_tmp11_ = fileDest;
					_tmp12_ = g_file_get_path (_tmp11_);
					path = _tmp12_;
					_tmp13_ = path;
					_tmp14_ = path;
					_tmp15_ = string_slice (_tmp13_, (glong) 0, (glong) string_last_index_of_char (_tmp14_, (gunichar) '/', 0));
					_g_free0 (path);
					path = _tmp15_;
					_tmp16_ = path;
					g_mkdir_with_parents (_tmp16_, 0755);
					_tmp17_ = fileSrc;
					_tmp18_ = fileDest;
					g_file_move (_tmp17_, _tmp18_, G_FILE_COPY_OVERWRITE, NULL, NULL, NULL, &_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						_g_free0 (path);
						_g_object_unref0 (fileDest);
						_g_object_unref0 (fileSrc);
						_g_free0 (e);
						goto __catch0_g_error;
					}
					nb = nb + 1;
					_tmp19_ = nb;
					_tmp20_ = list_length;
					_tmp21_ = basename;
					draw_install_file (_tmp19_, _tmp20_, _tmp21_);
					_g_free0 (path);
					_g_object_unref0 (fileDest);
					_g_object_unref0 (fileSrc);
					_g_free0 (e);
				}
			}
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp22_;
		const gchar* _tmp23_;
		gchar* _tmp24_;
		gchar* _tmp25_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp22_ = e->message;
		_tmp23_ = string_to_string (_tmp22_);
		_tmp24_ = g_strconcat ("FATAL ERROR >>> ", _tmp23_, NULL);
		_tmp25_ = _tmp24_;
		print_error (_tmp25_);
		_g_free0 (_tmp25_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static gchar**
_vala_array_dup2 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_vala_array_dup3 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

void
script_pre_install (const gchar* dir)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (dir != NULL);
	_tmp0_ = string_to_string (dir);
	_tmp1_ = g_strconcat (_tmp0_, "/pre_install.sh", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_EXECUTABLE);
	_g_free0 (_tmp2_);
	if (_tmp3_) {
		gchar** envp = NULL;
		gchar** _tmp4_;
		gchar** _tmp5_;
		gint envp_length1;
		gint _envp_size_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		gchar** _tmp7_;
		gint _tmp7__length1;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gchar** _tmp10_;
		gint _tmp10__length1;
		gchar** _tmp11_;
		gint _tmp11__length1;
		const gchar* _tmp12_;
		gchar** _tmp13_;
		gchar** _tmp14_;
		const gchar* _tmp15_;
		gchar* _tmp16_;
		gchar** _tmp17_;
		gchar** _tmp18_;
		gint _tmp18__length1;
		gchar** _tmp19_;
		gint _tmp19__length1;
		print_info (NULL, "Preparation");
		_tmp5_ = _tmp4_ = g_get_environ ();
		envp = _tmp5_;
		envp_length1 = _vala_array_length (_tmp4_);
		_envp_size_ = envp_length1;
		_tmp6_ = envp;
		_tmp6__length1 = envp_length1;
		_tmp7_ = (_tmp6_ != NULL) ? _vala_array_dup2 (_tmp6_, _tmp6__length1) : _tmp6_;
		_tmp7__length1 = _tmp6__length1;
		_tmp9_ = _tmp8_ = g_environ_setenv (_tmp7_, "SRCDIR", dir, TRUE);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
		envp = _tmp9_;
		envp_length1 = _vala_array_length (_tmp8_);
		_envp_size_ = envp_length1;
		_tmp10_ = envp;
		_tmp10__length1 = envp_length1;
		_tmp11_ = (_tmp10_ != NULL) ? _vala_array_dup3 (_tmp10_, _tmp10__length1) : _tmp10_;
		_tmp11__length1 = _tmp10__length1;
		_tmp12_ = PREFIX;
		_tmp14_ = _tmp13_ = g_environ_setenv (_tmp11_, "PKGDIR", _tmp12_, TRUE);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
		envp = _tmp14_;
		envp_length1 = _vala_array_length (_tmp13_);
		_envp_size_ = envp_length1;
		_tmp15_ = string_to_string (dir);
		_tmp16_ = g_strconcat (_tmp15_, "/pre_install.sh", NULL);
		_tmp17_ = g_new0 (gchar*, 1 + 1);
		_tmp17_[0] = _tmp16_;
		_tmp18_ = _tmp17_;
		_tmp18__length1 = 1;
		_tmp19_ = envp;
		_tmp19__length1 = envp_length1;
		utils_run (_tmp18_, (gint) 1, FALSE, _tmp19_, (gint) _tmp19__length1);
		_tmp18_ = (_vala_array_free (_tmp18_, _tmp18__length1, (GDestroyNotify) g_free), NULL);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
	}
}

static gchar**
_vala_array_dup4 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_vala_array_dup5 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

void
script_post_install (const gchar* dir)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (dir != NULL);
	_tmp0_ = string_to_string (dir);
	_tmp1_ = g_strconcat (_tmp0_, "/post_install.sh", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_test (_tmp2_, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_EXECUTABLE);
	_g_free0 (_tmp2_);
	if (_tmp3_) {
		gchar** envp = NULL;
		gchar** _tmp4_;
		gchar** _tmp5_;
		gint envp_length1;
		gint _envp_size_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		gchar** _tmp7_;
		gint _tmp7__length1;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gchar** _tmp10_;
		gint _tmp10__length1;
		gchar** _tmp11_;
		gint _tmp11__length1;
		const gchar* _tmp12_;
		gchar** _tmp13_;
		gchar** _tmp14_;
		const gchar* _tmp15_;
		gchar* _tmp16_;
		gchar** _tmp17_;
		gchar** _tmp18_;
		gint _tmp18__length1;
		gchar** _tmp19_;
		gint _tmp19__length1;
		_tmp5_ = _tmp4_ = g_get_environ ();
		envp = _tmp5_;
		envp_length1 = _vala_array_length (_tmp4_);
		_envp_size_ = envp_length1;
		_tmp6_ = envp;
		_tmp6__length1 = envp_length1;
		_tmp7_ = (_tmp6_ != NULL) ? _vala_array_dup4 (_tmp6_, _tmp6__length1) : _tmp6_;
		_tmp7__length1 = _tmp6__length1;
		_tmp9_ = _tmp8_ = g_environ_setenv (_tmp7_, "SRCDIR", dir, TRUE);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
		envp = _tmp9_;
		envp_length1 = _vala_array_length (_tmp8_);
		_envp_size_ = envp_length1;
		_tmp10_ = envp;
		_tmp10__length1 = envp_length1;
		_tmp11_ = (_tmp10_ != NULL) ? _vala_array_dup5 (_tmp10_, _tmp10__length1) : _tmp10_;
		_tmp11__length1 = _tmp10__length1;
		_tmp12_ = PREFIX;
		_tmp14_ = _tmp13_ = g_environ_setenv (_tmp11_, "PKGDIR", _tmp12_, TRUE);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
		envp = _tmp14_;
		envp_length1 = _vala_array_length (_tmp13_);
		_envp_size_ = envp_length1;
		print_info (NULL, "Finition");
		_tmp15_ = string_to_string (dir);
		_tmp16_ = g_strconcat (_tmp15_, "/post_install.sh", NULL);
		_tmp17_ = g_new0 (gchar*, 1 + 1);
		_tmp17_[0] = _tmp16_;
		_tmp18_ = _tmp17_;
		_tmp18__length1 = 1;
		_tmp19_ = envp;
		_tmp19__length1 = envp_length1;
		utils_run (_tmp18_, (gint) 1, FALSE, _tmp19_, (gint) _tmp19__length1);
		_tmp18_ = (_vala_array_free (_tmp18_, _tmp18__length1, (GDestroyNotify) g_free), NULL);
		envp = (_vala_array_free (envp, envp_length1, (GDestroyNotify) g_free), NULL);
	}
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

void
install_suprapackage (const gchar* suprapack)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (suprapack != NULL);
	utils_create_pixmaps_link ();
	if (g_file_test (suprapack, G_FILE_TEST_EXISTS)) {
		if (!g_str_has_suffix (suprapack, ".suprapack")) {
			print_error ("ce fichier n'est pas un suprapack");
		}
	} else {
		const gchar* _tmp0_;
		gchar* _tmp1_;
		gchar* _tmp2_;
		_tmp0_ = string_to_string (suprapack);
		_tmp1_ = g_strconcat (_tmp0_, " n'existe pas.", NULL);
		_tmp2_ = _tmp1_;
		print_error (_tmp2_);
		_g_free0 (_tmp2_);
	}
	{
		gchar* tmp_dir = NULL;
		gchar* _tmp3_;
		const gchar* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar** _tmp14_;
		gchar** _tmp15_;
		gint _tmp15__length1;
		gchar** _tmp16_;
		gchar** _tmp17_;
		gchar** _tmp18_;
		gint _tmp18__length1;
		Package pkg = {0};
		const gchar* _tmp19_;
		gchar* _tmp20_;
		gchar* _tmp21_;
		Package _tmp22_;
		const gchar* _tmp23_;
		Package _tmp26_;
		const gchar* _tmp27_;
		const gchar* _tmp35_;
		Package _tmp36_;
		const gchar* _tmp37_;
		const gchar* _tmp38_;
		Package _tmp39_;
		const gchar* _tmp40_;
		const gchar* _tmp41_;
		const gchar* _tmp42_;
		Package _tmp43_;
		const gchar* _tmp44_;
		const gchar* _tmp45_;
		gchar* _tmp46_;
		gchar* _tmp47_;
		GList* list = NULL;
		GList* _tmp48_;
		gint _tmp49_;
		gint _tmp50_;
		GList* _tmp51_;
		gint _tmp52_;
		gint _tmp53_;
		gchar* _tmp54_;
		gchar* _tmp55_;
		gchar* _tmp56_;
		gchar** _tmp57_;
		gchar** _tmp58_;
		gint _tmp58__length1;
		gchar** _tmp59_;
		gchar** _tmp60_;
		gchar** _tmp61_;
		gint _tmp61__length1;
		_tmp3_ = g_dir_make_tmp ("suprastore_XXXXXX", &_inner_error0_);
		tmp_dir = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp4_ = string_to_string (CYAN);
		_tmp5_ = string_to_string (suprapack);
		_tmp6_ = string_to_string (NONE);
		_tmp7_ = g_strconcat ("Extraction de ", _tmp4_, _tmp5_, _tmp6_, NULL);
		_tmp8_ = _tmp7_;
		print_info (_tmp8_, "SupraPack");
		_g_free0 (_tmp8_);
		_tmp9_ = g_strdup ("tar");
		_tmp10_ = g_strdup ("-xf");
		_tmp11_ = g_strdup (suprapack);
		_tmp12_ = g_strdup ("-C");
		_tmp13_ = g_strdup (tmp_dir);
		_tmp14_ = g_new0 (gchar*, 5 + 1);
		_tmp14_[0] = _tmp9_;
		_tmp14_[1] = _tmp10_;
		_tmp14_[2] = _tmp11_;
		_tmp14_[3] = _tmp12_;
		_tmp14_[4] = _tmp13_;
		_tmp15_ = _tmp14_;
		_tmp15__length1 = 5;
		_tmp17_ = _tmp16_ = g_get_environ ();
		_tmp18_ = _tmp17_;
		_tmp18__length1 = _vala_array_length (_tmp38_);
		utils_run (_tmp15_, (gint) 5, TRUE, _tmp18_, (gint) _vala_array_length (_tmp38_));
		_tmp18_ = (_vala_array_free (_tmp18_, _tmp18__length1, (GDestroyNotify) g_free), NULL);
		_tmp15_ = (_vala_array_free (_tmp15_, _tmp15__length1, (GDestroyNotify) g_free), NULL);
		_tmp19_ = string_to_string (tmp_dir);
		_tmp20_ = g_strconcat (_tmp19_, "/info", NULL);
		_tmp21_ = _tmp20_;
		package_init_from_file (&pkg, _tmp21_);
		_g_free0 (_tmp21_);
		_tmp22_ = pkg;
		_tmp23_ = _tmp22_.name;
		if (query_is_exist (_tmp23_)) {
			Package _tmp24_;
			const gchar* _tmp25_;
			_tmp24_ = pkg;
			_tmp25_ = _tmp24_.name;
			query_uninstall (_tmp25_);
		}
		_tmp26_ = pkg;
		_tmp27_ = _tmp26_.dependency;
		if (g_strcmp0 (_tmp27_, "") != 0) {
			gchar** dep_list = NULL;
			Package _tmp28_;
			const gchar* _tmp29_;
			gchar** _tmp30_;
			gchar** _tmp31_;
			gint dep_list_length1;
			gint _dep_list_size_;
			gchar** _tmp32_;
			gint _tmp32__length1;
			print_info ("search dependency...", "Dependency");
			_tmp28_ = pkg;
			_tmp29_ = _tmp28_.dependency;
			_tmp31_ = _tmp30_ = g_strsplit (_tmp29_, " ", 0);
			dep_list = _tmp31_;
			dep_list_length1 = _vala_array_length (_tmp30_);
			_dep_list_size_ = dep_list_length1;
			_tmp32_ = dep_list;
			_tmp32__length1 = dep_list_length1;
			{
				gchar** dep_collection = NULL;
				gint dep_collection_length1 = 0;
				gint _dep_collection_size_ = 0;
				gint dep_it = 0;
				dep_collection = _tmp32_;
				dep_collection_length1 = _tmp32__length1;
				for (dep_it = 0; dep_it < dep_collection_length1; dep_it = dep_it + 1) {
					gchar* _tmp33_;
					gchar* dep = NULL;
					_tmp33_ = g_strdup (dep_collection[dep_it]);
					dep = _tmp33_;
					{
						const gchar* _tmp34_;
						_tmp34_ = dep;
						install (_tmp34_, FALSE);
						_g_free0 (dep);
					}
				}
			}
			print_info ("All dependencies have been installed !", "Dependency");
			dep_list = (_vala_array_free (dep_list, dep_list_length1, (GDestroyNotify) g_free), NULL);
		}
		script_pre_install (tmp_dir);
		_tmp35_ = string_to_string (CYAN);
		_tmp36_ = pkg;
		_tmp37_ = _tmp36_.name;
		_tmp38_ = string_to_string (_tmp37_);
		_tmp39_ = pkg;
		_tmp40_ = _tmp39_.version;
		_tmp41_ = string_to_string (_tmp40_);
		_tmp42_ = string_to_string (NONE);
		_tmp43_ = pkg;
		_tmp44_ = _tmp43_.author;
		_tmp45_ = string_to_string (_tmp44_);
		_tmp46_ = g_strconcat ("Installation de ", _tmp35_, _tmp38_, " ", _tmp41_, _tmp42_, " par ", _tmp45_, NULL);
		_tmp47_ = _tmp46_;
		print_info (_tmp47_, "SupraPack");
		_g_free0 (_tmp47_);
		list = NULL;
		list_file_dir (tmp_dir, &list);
		_tmp48_ = list;
		_tmp49_ = strlen (tmp_dir);
		_tmp50_ = _tmp49_;
		install_files (_tmp48_, _tmp50_);
		script_post_install (tmp_dir);
		_tmp51_ = list;
		_tmp52_ = strlen (tmp_dir);
		_tmp53_ = _tmp52_;
		post_install (_tmp51_, _tmp53_, &pkg);
		_tmp54_ = g_strdup ("rm");
		_tmp55_ = g_strdup ("-rf");
		_tmp56_ = g_strdup (tmp_dir);
		_tmp57_ = g_new0 (gchar*, 3 + 1);
		_tmp57_[0] = _tmp54_;
		_tmp57_[1] = _tmp55_;
		_tmp57_[2] = _tmp56_;
		_tmp58_ = _tmp57_;
		_tmp58__length1 = 3;
		_tmp60_ = _tmp59_ = g_get_environ ();
		_tmp61_ = _tmp60_;
		_tmp61__length1 = _vala_array_length (_tmp38_);
		utils_run (_tmp58_, (gint) 3, TRUE, _tmp61_, (gint) _vala_array_length (_tmp38_));
		_tmp61_ = (_vala_array_free (_tmp61_, _tmp61__length1, (GDestroyNotify) g_free), NULL);
		_tmp58_ = (_vala_array_free (_tmp58_, _tmp58__length1, (GDestroyNotify) g_free), NULL);
		(list == NULL) ? NULL : (list = (_g_list_free__g_free0_ (list), NULL));
		package_destroy (&pkg);
		_g_free0 (tmp_dir);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp62_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp62_ = e->message;
		print_error (_tmp62_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static gpointer
_sync_ref0 (gpointer self)
{
	return self ? sync_ref (self) : NULL;
}

static void
_vala_SupraList_array_free (SupraList * array,
                            gssize array_length)
{
	if (array != NULL) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			supra_list_destroy (&array[i]);
		}
	}
	g_free (array);
}

void
install (const gchar* name_search,
         gboolean force)
{
	Sync* sync = NULL;
	Sync* _tmp0_;
	Sync* _tmp1_;
	gchar* output = NULL;
	SupraList* list = NULL;
	Sync* _tmp2_;
	gint _tmp3_ = 0;
	SupraList* _tmp4_;
	gint list_length1;
	gint _list_size_;
	SupraList* _tmp5_;
	gint _tmp5__length1;
	g_return_if_fail (name_search != NULL);
	_tmp0_ = sync_default ();
	_tmp1_ = _sync_ref0 (_tmp0_);
	sync = _tmp1_;
	_tmp2_ = sync;
	_tmp4_ = sync_get_list_package (_tmp2_, &_tmp3_);
	list = _tmp4_;
	list_length1 = _tmp3_;
	_list_size_ = list_length1;
	_tmp5_ = list;
	_tmp5__length1 = list_length1;
	{
		SupraList* pkg_collection = NULL;
		gint pkg_collection_length1 = 0;
		gint _pkg_collection_size_ = 0;
		gint pkg_it = 0;
		pkg_collection = _tmp5_;
		pkg_collection_length1 = _tmp5__length1;
		for (pkg_it = 0; pkg_it < pkg_collection_length1; pkg_it = pkg_it + 1) {
			SupraList _tmp6_;
			SupraList _tmp7_ = {0};
			SupraList pkg = {0};
			_tmp6_ = pkg_collection[pkg_it];
			supra_list_copy (&_tmp6_, &_tmp7_);
			pkg = _tmp7_;
			{
				SupraList _tmp8_;
				const gchar* _tmp9_;
				_tmp8_ = pkg;
				_tmp9_ = _tmp8_.name;
				if (g_strcmp0 (_tmp9_, name_search) == 0) {
					SupraList _tmp16_;
					const gchar* _tmp17_;
					const gchar* _tmp18_;
					SupraList _tmp19_;
					const gchar* _tmp20_;
					const gchar* _tmp21_;
					SupraList _tmp22_;
					const gchar* _tmp23_;
					const gchar* _tmp24_;
					gchar* _tmp25_;
					gchar* _tmp26_;
					Sync* _tmp27_;
					SupraList _tmp28_;
					gchar* _tmp29_;
					const gchar* _tmp30_;
					if (force == FALSE) {
						SupraList _tmp10_;
						const gchar* _tmp11_;
						_tmp10_ = pkg;
						_tmp11_ = _tmp10_.name;
						if (query_is_exist (_tmp11_) == TRUE) {
							SupraList _tmp12_;
							const gchar* _tmp13_;
							_tmp12_ = pkg;
							_tmp13_ = _tmp12_.name;
							if (sync_check_update (_tmp13_)) {
								SupraList _tmp14_;
								const gchar* _tmp15_;
								_tmp14_ = pkg;
								_tmp15_ = _tmp14_.name;
								update_package (_tmp15_, TRUE);
							}
							supra_list_destroy (&pkg);
							list = (_vala_SupraList_array_free (list, list_length1), NULL);
							_g_free0 (output);
							_sync_unref0 (sync);
							return;
						}
					}
					_tmp16_ = pkg;
					_tmp17_ = _tmp16_.name;
					_tmp18_ = string_to_string (_tmp17_);
					_tmp19_ = pkg;
					_tmp20_ = _tmp19_.version;
					_tmp21_ = string_to_string (_tmp20_);
					_tmp22_ = pkg;
					_tmp23_ = _tmp22_.repo_name;
					_tmp24_ = string_to_string (_tmp23_);
					_tmp25_ = g_strconcat (_tmp18_, ":", _tmp21_, " found in ", _tmp24_, NULL);
					_tmp26_ = _tmp25_;
					print_info (_tmp26_, "SupraPack");
					_g_free0 (_tmp26_);
					_tmp27_ = sync;
					_tmp28_ = pkg;
					_tmp29_ = sync_download (_tmp27_, &_tmp28_);
					_g_free0 (output);
					output = _tmp29_;
					_tmp30_ = output;
					install_suprapackage (_tmp30_);
					supra_list_destroy (&pkg);
					list = (_vala_SupraList_array_free (list, list_length1), NULL);
					_g_free0 (output);
					_sync_unref0 (sync);
					return;
				}
				supra_list_destroy (&pkg);
			}
		}
	}
	if (query_is_exist (name_search) == TRUE) {
		const gchar* _tmp31_;
		gchar* _tmp32_;
		gchar* _tmp33_;
		_tmp31_ = string_to_string (name_search);
		_tmp32_ = g_strconcat ("Can't install ", _tmp31_, " but exist in local", NULL);
		_tmp33_ = _tmp32_;
		print_info (_tmp33_, "SupraPack");
		_g_free0 (_tmp33_);
	} else {
		const gchar* _tmp34_;
		gchar* _tmp35_;
		gchar* _tmp36_;
		_tmp34_ = string_to_string (name_search);
		_tmp35_ = g_strconcat (_tmp34_, " doesn't exist", NULL);
		_tmp36_ = _tmp35_;
		print_error (_tmp36_);
		_g_free0 (_tmp36_);
	}
	list = (_vala_SupraList_array_free (list, list_length1), NULL);
	_g_free0 (output);
	_sync_unref0 (sync);
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

