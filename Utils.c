/* Utils.c generated by valac 0.56.13, the Vala compiler
 * generated from Utils.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <stdio.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

VALA_EXTERN void utils_create_pixmaps_link (void);
VALA_EXTERN gint utils_run_cmd (gchar** av,
                    gint av_length1);
VALA_EXTERN void print_error (const gchar* msg);
VALA_EXTERN gint utils_run (gchar** av,
                gint av_length1,
                gboolean silence,
                gchar** envp,
                gint envp_length1);
VALA_EXTERN gchar* utils_get_input (const gchar* msg);

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

void
utils_create_pixmaps_link (void)
{
	gchar* HOME = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GError* _inner_error0_ = NULL;
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_strdup (_tmp0_);
	HOME = _tmp1_;
	{
		gchar* pixmaps = NULL;
		const gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		_tmp2_ = HOME;
		_tmp3_ = string_to_string (_tmp2_);
		_tmp4_ = g_strconcat (_tmp3_, "/.local/share/pixmaps", NULL);
		pixmaps = _tmp4_;
		_tmp5_ = pixmaps;
		if (g_file_test (_tmp5_, G_FILE_TEST_IS_SYMLINK)) {
			_g_free0 (pixmaps);
			_g_free0 (HOME);
			return;
		} else {
			const gchar* _tmp6_;
			_tmp6_ = pixmaps;
			if (g_file_test (_tmp6_, G_FILE_TEST_EXISTS)) {
				const gchar* _tmp7_;
				GFile* file = NULL;
				const gchar* _tmp8_;
				GFile* _tmp9_;
				GFile* _tmp10_;
				const gchar* _tmp11_;
				const gchar* _tmp12_;
				gchar* _tmp13_;
				gchar* _tmp14_;
				_tmp7_ = pixmaps;
				g_remove (_tmp7_);
				_tmp8_ = pixmaps;
				_tmp9_ = g_file_new_for_path (_tmp8_);
				file = _tmp9_;
				_tmp10_ = file;
				_tmp11_ = HOME;
				_tmp12_ = string_to_string (_tmp11_);
				_tmp13_ = g_strconcat (_tmp12_, "/.icons", NULL);
				_tmp14_ = _tmp13_;
				g_file_make_symbolic_link (_tmp10_, _tmp14_, NULL, &_inner_error0_);
				_g_free0 (_tmp14_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_object_unref0 (file);
					_g_free0 (pixmaps);
					goto __catch0_g_error;
				}
				_g_object_unref0 (file);
			} else {
				const gchar* _tmp15_;
				const gchar* _tmp16_;
				gchar* _tmp17_;
				gchar* _tmp18_;
				GFile* file = NULL;
				const gchar* _tmp19_;
				GFile* _tmp20_;
				GFile* _tmp21_;
				const gchar* _tmp22_;
				const gchar* _tmp23_;
				gchar* _tmp24_;
				gchar* _tmp25_;
				_tmp15_ = HOME;
				_tmp16_ = string_to_string (_tmp15_);
				_tmp17_ = g_strconcat (_tmp16_, "/.local/share/", NULL);
				_tmp18_ = _tmp17_;
				g_mkdir_with_parents (_tmp18_, 0755);
				_g_free0 (_tmp18_);
				_tmp19_ = pixmaps;
				_tmp20_ = g_file_new_for_path (_tmp19_);
				file = _tmp20_;
				_tmp21_ = file;
				_tmp22_ = HOME;
				_tmp23_ = string_to_string (_tmp22_);
				_tmp24_ = g_strconcat (_tmp23_, "/.icons", NULL);
				_tmp25_ = _tmp24_;
				g_file_make_symbolic_link (_tmp21_, _tmp25_, NULL, &_inner_error0_);
				_g_free0 (_tmp25_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_object_unref0 (file);
					_g_free0 (pixmaps);
					goto __catch0_g_error;
				}
				_g_object_unref0 (file);
			}
		}
		_g_free0 (pixmaps);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp26_;
		const gchar* _tmp27_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp26_ = e;
		_tmp27_ = _tmp26_->message;
		g_printerr ("%s", _tmp27_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (HOME);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (HOME);
}

gint
utils_run_cmd (gchar** av,
               gint av_length1)
{
	gint _tmp4_ = -1;
	GError* _inner_error0_ = NULL;
	gint result;
	{
		GSubprocess* pid = NULL;
		GSubprocess* _tmp0_;
		GSubprocess* _tmp1_;
		GSubprocess* _tmp2_;
		_tmp0_ = g_subprocess_newv (av, G_SUBPROCESS_FLAGS_STDERR_SILENCE | G_SUBPROCESS_FLAGS_STDOUT_SILENCE, &_inner_error0_);
		pid = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp1_ = pid;
		g_subprocess_wait (_tmp1_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (pid);
			goto __catch0_g_error;
		}
		_tmp2_ = pid;
		result = g_subprocess_get_status (_tmp2_);
		_g_object_unref0 (pid);
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = e->message;
		print_error (_tmp3_);
		_g_error_free0 (e);
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return _tmp4_;
}

gint
utils_run (gchar** av,
           gint av_length1,
           gboolean silence,
           gchar** envp,
           gint envp_length1)
{
	gint status = 0;
	GSpawnFlags flags = 0U;
	gint _tmp2_ = -1;
	GError* _inner_error0_ = NULL;
	gint result;
	if (silence == TRUE) {
		flags = ((G_SPAWN_SEARCH_PATH_FROM_ENVP | G_SPAWN_CHILD_INHERITS_STDIN) | G_SPAWN_STDERR_TO_DEV_NULL) | G_SPAWN_STDOUT_TO_DEV_NULL;
	} else {
		flags = G_SPAWN_SEARCH_PATH_FROM_ENVP | G_SPAWN_CHILD_INHERITS_STDIN;
	}
	{
		gint _tmp0_ = 0;
		g_spawn_sync ("/", av, envp, G_SPAWN_SEARCH_PATH | G_SPAWN_CHILD_INHERITS_STDIN, NULL, NULL, NULL, NULL, &_tmp0_, &_inner_error0_);
		status = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		result = status;
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp1_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp1_ = e->message;
		print_error (_tmp1_);
		_g_error_free0 (e);
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return _tmp2_;
}

static gchar*
g_file_stream_read_line (FILE* self)
{
	gint c = 0;
	GString* ret = NULL;
	GString* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	while (TRUE) {
		GString* _tmp0_;
		GString* _tmp2_;
		c = fgetc (self);
		if (!(c != EOF)) {
			break;
		}
		_tmp0_ = ret;
		if (_tmp0_ == NULL) {
			GString* _tmp1_;
			_tmp1_ = g_string_new ("");
			_g_string_free0 (ret);
			ret = _tmp1_;
		}
		if (c == ((gint) '\n')) {
			break;
		}
		_tmp2_ = ret;
		g_string_append_c ((GString*) _tmp2_, (gchar) c);
	}
	_tmp3_ = ret;
	if (_tmp3_ == NULL) {
		result = NULL;
		_g_string_free0 (ret);
		return result;
	} else {
		GString* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp4_ = ret;
		_tmp5_ = ((GString*) _tmp4_)->str;
		_tmp6_ = g_strdup (_tmp5_);
		result = _tmp6_;
		_g_string_free0 (ret);
		return result;
	}
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

gchar*
utils_get_input (const gchar* msg)
{
	gchar* str = NULL;
	FILE* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp7_;
	gchar* result;
	g_return_val_if_fail (msg != NULL, NULL);
	g_print ("%s", msg);
	_tmp0_ = stdin;
	_tmp1_ = g_file_stream_read_line (_tmp0_);
	str = _tmp1_;
	_tmp2_ = str;
	if (_tmp2_ != NULL) {
		const gchar* _tmp3_;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp3_ = str;
		_tmp4_ = g_utf8_strdown (_tmp3_, (gssize) -1);
		_g_free0 (str);
		str = _tmp4_;
		_tmp5_ = str;
		_tmp6_ = string_strip (_tmp5_);
		_g_free0 (str);
		str = _tmp6_;
		result = str;
		return result;
	}
	_tmp7_ = g_strdup ("");
	result = _tmp7_;
	_g_free0 (str);
	return result;
}

